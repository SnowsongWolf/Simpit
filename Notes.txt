- DirectX Limits
  - 32 Buttons
  - 8 Axis
  - 8 direction digital hat

- Things to learn
  - How do I unbind an axis?
    - May be able to assign an axis to null which is 0
  - Is there any way to read external information in?

  
- QT interlock
  - Can't initiate QT with landing gear down
  - QT can still be spooled up
  
- Landing Gear interlock
  - Can't raise gear with engines off
  - Can't toggle gear when gear is in motion (need to time this)
  - Blinkey light when gear is in motion
  
- left stick hat
  - up sets button to afterburner
  - down sets button to space brake
  - left toggles decouple
  - right toggles cruise
  - center click toggles rear view
  
Flight mode:
Warthog JOYX -> DX_X_AXIS
Warthog JOYY -> DX_Y_AXIS
Warthog THR_LEFT -> 0
Warthog THR_RIGHT -> DX_THROTTLE_AXIS
Warthog THR_FC -> DX_SLIDER_AXIS
T.16000 JOYX -> DX_XROT_AXIS
T.16000 JOYY -> DX_ROTY_AXIS
T.16000 RUDDER -> DX_ROTZ_AXIS

Hover mode:
Use pedals for thrust/brake
Use stick for steering
Use rudder for roll

Ground mode:
Use pedals for thrust/brake
Use stick for steering
Use rudder for roll


Simulate coast - On ground throttle will have a slow falloff when letting off accel peddal, will have much faster falloff when hitting brake pedal

Use left throttle as gear shift.  Below X = reverse, above X = multiplier?
Looks like I will have to use Trim for this.  In theory I can unbind an axis and just use trim to set the value.

Maybe not.  Looks like I can use Axis(axis, value) to manually set a virtual DX axis to a value of my choice.  Though this is functionally the same as using trim(axis, SET(value)) but it's a little less typing I s'pose.  We should try to do this only when we get a pedal event update.

Screens:

Target
cycle targets
pin targets
deselect targets
DMS selects targeting mode (friendly, enemy, pinned, all)
TMS cycles/clears target

AIM9
lock targets
fire missile
cycle gimbal mode
sub targeting

Camera
freeview
rear view
orbit/strafe
zoom/strafe

Power
to weapons/toggle
to engines/toggle
to shields/toggle
reset/flight ready

Some kind of display on monitor to denote the current mode?  Otherwise use LEDs for now.


This is how the system is doing it
//--------------------------------------------------------------------
//	LED Functions
//--------------------------------------------------------------------
int Blink_LED(int led, int blinkrate)
{
	// This function will blink an LED
	//
    // Parameters:
	//	int led: The Throttle LED to blink
	//	int blinkrate: The rate at which to blink the LED
	//
    // Returns:
		
	ActKey(KEYON + CHAIN(LED(&Throttle, LED_ONOFF, LED_CURRENT + led), D(blinkrate), LED(&Throttle, LED_ONOFF, LED_CURRENT - led)));
}

int BlinkAfterburner()
{
	// This function will blink LED1 when the Afterburner toggle is on
	//
    // Parameters:
	//
    // Returns:
    
	ActKey(KEYON + StopAutoRepeat(AfterburnerRIDX));
	ActKey(KEYON + REXEC(AfterburnerRIDX, 300, "Blink_LED(LED1, 150);", RNOSTOP));
}
